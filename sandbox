// This code is licensed under the same terms as Habitica:
  // https://raw.githubusercontent.com/HabitRPG/habitrpg/develop/LICENSE

/* ========================================== */
/* [Users] Required script data to fill in    */
/* ========================================== */
const USER_ID = "f2d3eaf9-d54a-4001-919d-ee9b8d4884f5";
const API_TOKEN = "f9df13e9-1066-4212-8f12-b997ebc5bcd6"; // Do not share this to anyone
const WEB_APP_URL = "https://script.google.com/macros/s/AKfycbwiu6l94CpHW2B9D0imHbalYzvARZ8LSPOwRM_7uWmjeUbG5TwP/exec";

/* ========================================== */
/* [Users] Required customizations to fill in */
/* ========================================== */

/* ========================================== */
/* [Users] Optional customizations to fill in */
/* ========================================== */

const NOTIFICATIONS_ON = 1; 

/* ========================================== */
/* [Users] Do not edit code below this line   */
/* ========================================== */
const AUTHOR_ID = "0034eb14-b4d8-494e-8386-d3f33cff7922";
const SCRIPT_NAME = "boss damage â€“ testing some things";
const HEADERS = {
  "x-client" : AUTHOR_ID + "-" + SCRIPT_NAME,
  "x-api-user" : USER_ID,
  "x-api-key" : API_TOKEN,
}

const scriptProperties = PropertiesService.getScriptProperties(); // Constants can have properties changed

const STR_BUFF_KEY = "STR_BUFF_KEY";
const INT_BUFF_KEY = "INT_BUFF_KEY";
const PER_BUFF_KEY = "PER_BUFF_KEY";
const LVL_KEY = "LVL_KEY";
const MP_KEY = "MP_KEY";
const HP_KEY = "HP_KEY";
const XP_KEY = "XP_KEY";
const GP_KEY = "GP_KEY";

var strBuffKey = "";
var intBuffKey = "";
var perBuffKey = "";
var lvlKey = "";
var mpKey = "";
var hpKey = "";
var xpKey = "";
var gpKey = "";

const TEST_TEXT = "**trigger test**";
const TEST_ALIAS = "test";
const TEST_NOTES = "triggers whatever I'm testing";
const TEST_VALUE = "0";

const TEST_BUTTON = {
    "text": TEST_TEXT,
    "type": "reward",
    "alias": TEST_ALIAS,
    "notes": TEST_NOTES,
    "value": TEST_VALUE,
}

const DAMAGE_TEXT = "**boss damage**";
const DAMAGE_NOTES = "used to create boss damage";

const DAMAGE_BUTTON = {
    "text": DAMAGE_TEXT,
    "type": "todo",
    "notes": DAMAGE_NOTES,
    "priority": 0.1,
}

function doOneTimeSetup() { 
  api_createNewTaskForUser([TEST_BUTTON]);
  // create the webhook
  const options = {
    "scored" : true,
  }
  const payload = {
    "url" : WEB_APP_URL,
    "label" : SCRIPT_NAME + " Webhook",
    "type" : "taskActivity",
    "options" : options,
  }
  apiMult_createNewWebhookNoDuplicates(payload);
  
  initScriptProperties();
}

// do things when the webhook runs
function doPost(e) {
  const dataContents = JSON.parse(e.postData.contents);
  const type = dataContents.type;
  const task = dataContents.task;
  
  // Sanitize task alias
  if ((task.alias == undefined) || (task.alias == null)) {
    task.alias = "";
  }
  
  if ( (type == "scored") && (task.alias == TEST_ALIAS) ) {
    var strBuffKey = STR_BUFF_KEY;
    var intBuffKey = INT_BUFF_KEY;
    var perBuffKey = PER_BUFF_KEY;
    var lvlKey = LVL_KEY;
    var mpKey = MP_KEY;
    var hpKey = HP_KEY;
    var xpKey = XP_KEY;
    var gpKey = GP_KEY;  
    
    const responseUser = api_getAuthenticatedUserProfile("stats,items.gear.equipped");
    user = JSON.parse(responseUser).data;
    
    const responseContent = apiFree_getAllAvailableContentObjects();
    content = JSON.parse(responseContent).data;
    
    var str = calculateStrength();
    var int = calculateIntelligence();
    var con = calculateConstitution();
    var per = calculatePerception();
    
    var strBuff = user.stats.buffs.str;
    var intBuff = user.stats.buffs.int;
    var perBuff = user.stats.buffs.per;
    
    var unbuffedStr = str - strBuff;
    var unbuffedInt = int - intBuff;
    var unbuffedPer = per - perBuff;
    
    var lvl = user.stats.lvl;
    var mp = user.stats.mp;
    var hp = user.stats.hp;
    var xp = user.stats.exp;
    var gp = user.stats.gp;
    
    // Save values to non-volatile memory so I can revert back after doing damage
    scriptProperties.setProperty(strBuffKey, strBuff)
    scriptProperties.setProperty(intBuffKey, intBuff);
    scriptProperties.setProperty(perBuffKey, perBuff);
    scriptProperties.setProperty(lvlKey, lvl);
    scriptProperties.setProperty(mpKey, mp);
    scriptProperties.setProperty(hpKey, hp);
    scriptProperties.setProperty(xpKey, xp);
    scriptProperties.setProperty(gpKey, gp);
    
    var flames = flamesDamage (int);
    var smash = smashDamage (str, con);
    
    var expectedDamage = smash * 2;
    
    // Set INT and PER to 0
    api_updateUser({"stats.buffs.int" : (-1 * unbuffedInt) , "stats.buffs.per" : (-1 * unbuffedPer), "stats.buffs.str" : 10000  });
    
    // This case won't happen for a single use of either damage skill, but will for multi-use ones
    if (expectedDamage >= 77.49) {
      damageHigh(expectedDamage, unbuffedStr);
    }
    else {
      // turning it into binary is the least processing-intensive and therefore best for rate limiting
      // damage is the weighted average of crit and non-crit, so it won't be perfect, but over time, it will equal the correct amount (on average)
      var dividedBy64 = Math.floor(expectedDamage / 64);
      damage(dividedBy64, unbuffedStr, 2892);
      
      var remainderFrom64 = expectedDamage - (64 * dividedBy64);
      var dividedBy32 = Math.floor(remainderFrom64 / 32);
      damage(dividedBy32, unbuffedStr, 1880);
      
      var remainderFrom32 = remainderFrom64 - (32 * dividedBy32);
      var dividedBy16 = Math.floor(remainderFrom32 / 16);
      damage(dividedBy16, unbuffedStr, 1171);
      
      var remainderFrom16 = remainderFrom32 - (16 * dividedBy16);
      var dividedBy8 = Math.floor(remainderFrom16 / 8);
      damage(dividedBy8, unbuffedStr, 680);
      
      var remainderFrom8 = remainderFrom16 - (8 * dividedBy8);
      var dividedBy4 = Math.floor(remainderFrom8 / 4);
      damage(dividedBy4, unbuffedStr, 362);
      
      var remainderFrom4 = remainderFrom8 - (4 * dividedBy4);
      var dividedBy2 = Math.floor(remainderFrom4 / 2);
      damage(dividedBy2, unbuffedStr, 145);
      
      var remainderFrom2 = remainderFrom4 - (4 * dividedBy2);
      var dividedBy1 = Math.ceil(remainderFrom2); // do Ceiling instead of Floor for the final one
      damage(dividedBy1, unbuffedStr, 1);
    }
    
    // pause for 5 seconds
    Utilities.sleep(5000);
    
    // Revert all stats back to their saved values
    strBuff = Number(scriptProperties.getProperty(strBuffKey));
    intBuff = Number(scriptProperties.getProperty(intBuffKey));
    perBuff = Number(scriptProperties.getProperty(perBuffKey));
    lvl = Number(scriptProperties.getProperty(lvlKey));
    mp = Number(scriptProperties.getProperty(mpKey));
    hp = Number(scriptProperties.getProperty(hpKey));
    xp = Number(scriptProperties.getProperty(xpKey));
    gp = Number(scriptProperties.getProperty(gpKey));
    
    // do API Update user to set everything to the above
    api_updateUser({"stats.buffs.str" : strBuff, "stats.buffs.int" : intBuff, "stats.buffs.per" : perBuff, "stats.lvl" : lvl, "stats.mp" : mp, "stats.hp" : hp, "stats.exp" : xp, "stats.gp" : gp});
    
    // pause for 1 minute for the sake of rate limiting
    Utilities.sleep(60000);
  }
  return HtmlService.createHtmlOutput();
}

// Create task
function api_createNewTaskForUser(payload) {
  var params = {
    "method" : "post",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload), // Rightmost button goes on top
    "muteHttpExceptions" : true,
  }

  var url = "https://habitica.com/api/v3/tasks/user";
  UrlFetchApp.fetch(url, params);
}

// Create a webhook if no duplicate exists
function apiMult_createNewWebhookNoDuplicates(payload) {
  const response = api_getWebhooks();
  const webhooks = JSON.parse(response).data;
  var duplicateExists = 0;
    
  for (var i in webhooks) {
    if (webhooks[i].label == payload.label) {
      duplicateExists = 1;
    }
  }
  // If webhook to be created doesn't exist yet
  if (!duplicateExists) {
    api_createNewWebhook(payload);
  }
}

// Used to see existing webhooks, and therefore if there's a duplicate
function api_getWebhooks() {
  const params = {
    "method" : "get",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }
  
  const url = "https://habitica.com/api/v3/user/webhook";
  return UrlFetchApp.fetch(url, params);
}

// Creates a webhook (as part of the "don't make it if there's a duplicate" function)
function api_createNewWebhook(payload) {
  const params = {
    "method" : "post",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload),
    "muteHttpExceptions" : true,
  }
   
  const url = "https://habitica.com/api/v3/user/webhook";
  return UrlFetchApp.fetch(url, params);
}

// Initialize values
function initScriptProperties() {
  scriptProperties.setProperty(STR_BUFF_KEY, 0);
  scriptProperties.setProperty(INT_BUFF_KEY, 0);
  scriptProperties.setProperty(PER_BUFF_KEY, 0);
  scriptProperties.setProperty(LVL_KEY, 0);
  scriptProperties.setProperty(MP_KEY, 0);
  scriptProperties.setProperty(HP_KEY, 0);
  scriptProperties.setProperty(XP_KEY, 0);
  scriptProperties.setProperty(GP_KEY, 0);
}

// Score a task
function api_scoreTask(aliasOrId, direction) {
  var params = {
    "method" : "post",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }

  var url = "https://habitica.com/api/v3/tasks/";
  if ( (aliasOrId != "") && (direction != "") ) {
    url += aliasOrId + "/score/" + direction;
  }
  return UrlFetchApp.fetch(url, params);
}

function api_getUserTasks(type) {
  const params = {
    "method" : "get",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }
  
  var url = "https://habitica.com/api/v3/tasks/user";
  if (type != "") {
    url += "?type=" + type;
  }

  return UrlFetchApp.fetch(url, params);
}

// Expected damage for Burst of Flames
function flamesDamage (int) {
  return Math.ceil(int/10);
}

// Expected damage for Brutal Smash
function smashDamage (str, con) {
  var multiplier = criticalHit(con, 0.03);
  var bonus = str * multiplier;
  return (55*bonus)/(bonus+70);
}

function criticalHit (stat, chance) {
  var targetToBeat = chance * ( (1 + stat ) / 100 );
  if (Math.random() <= targetToBeat) {
    return (1.5 +  ( 4 * stat ) / ( stat + 200 ) );
  }
  else {
    return 1;
  }
}

// Damage for when critical hit on task is guaranteed (damage >= 77.49, STR >= 3244)
function damageHigh(expectedDamage, unbuffedStr) {
  // since crit is guaranteed and crit multiplier is capped at 4.5 and task value delta for a new task (value 0) is 1, damage is 4.5*(1+(str*0.005))
  // to calculate what amount of STR is needed to do the expected amount of damage, do algebra. The result is STR = (damage-4.5)/0.0225
  
  var strSetpoint = Math.ceil( (expectedDamage - 4.5) / (0.0225) );
  api_updateUser({"stats.buffs.str" : (strSetpoint - unbuffedStr)}); // set STR to setpoint
  
  // Create one To-Do and check it off.
  api_createNewTaskForUser(DAMAGE_BUTTON);
  
  // pause for 1 second to give the script enough time between creating the task and scoring it
  Utilities.sleep(1000);
  
  const responseTaskHigh = api_getUserTasks("todos");
  const tasksForDamageHigh = JSON.parse(responseTaskHigh).data;
  var taskIdForDamageHigh = "";
  for (var j in tasksForDamageHigh) {
    if ( (tasksForDamageHigh[j].text == DAMAGE_TEXT) && (tasksForDamageHigh[j].notes == DAMAGE_NOTES) ) {
      taskIdForDamageHigh = tasksForDamageHigh[j]._id;
      api_scoreTask(taskIdForDamageHigh, "up");
    }
  }
}

// Damage is approximate and is calculated as the weighted average of crit and non-crit damage for a given task.
// The damage amounts and STR setpoints are: 64.03 damage at 2892 STR, 32.02 damage at 1880 STR, 16.00 damage at 1171 STR, 8.00 damage at 680 STR, 4.01 damage at 362 STR, 2.00 damage at 145 STR, and 1.02 damage at 1 STR
function damage(dividesInto, unbuffedStr, strSetpoint) {
  if (dividesInto > 0 ) {
    api_updateUser({"stats.buffs.str" : (strSetpoint - unbuffedStr)}); // set STR to setpoint
    
    // Create one To-Do and check it off.
    api_createNewTaskForUser(DAMAGE_BUTTON);
    
    // pause for 0.2 seconds to give the script enough time between creating the task and scoring it
    Utilities.sleep(200);
    
    const responseTask = api_getUserTasks("todos");
    const tasksForDamage = JSON.parse(responseTask).data;
    var taskIdForDamage = "";
    for (var j in tasksForDamage) {
      if ( (tasksForDamage[j].text == DAMAGE_TEXT) && (tasksForDamage[j].notes == DAMAGE_NOTES) ) {
        taskIdForDamage = tasksForDamage[j]._id;
        api_scoreTask(taskIdForDamage, "up");
      }
    }
  }
}

// Add an item to checklist
function api_addItemToTaskChecklist(aliasOrId, payload) {
  var params = {
    "method" : "post",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload),
    "muteHttpExceptions" : true,
  }

  var url = "https://habitica.com/api/v3/tasks/";
  if (aliasOrId != "") {
    url += aliasOrId + "/checklist";
  }
  return UrlFetchApp.fetch(url, params);
}

// Gets user info so I can use it, especially stats like mana, experience, and level
function api_getAuthenticatedUserProfile(userFields) {
  const params = {
    "method" : "get",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }
  
  var url = "https://habitica.com/api/v3/user";
  if (userFields != "") {
    url += "?userFields=" + userFields;
  }

  return UrlFetchApp.fetch(url, params);
}

function apiFree_getAllAvailableContentObjects() {
  const params = {
    "method" : "get",
    "muteHttpExceptions" : true,
  }
  
  const url = "https://habitica.com/api/v3/content";
  return UrlFetchApp.fetch(url, params);
}

function api_updateUser(payload) { 
  const params = {
    "method" : "put",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload),
    "muteHttpExceptions" : true,
  }
  
  const url = "https://habitica.com/api/v3/user";
  return UrlFetchApp.fetch(url, params);
}

function calculateStrength() {
  const levelStr = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassStr = 0;
  const allocatedStr = user.stats.str;
  const buffsStr = user.stats.buffs.str;
  
  // Get STR from equipped gear
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.back]);

  return levelStr + totalEquipmentAndClassStr + allocatedStr + buffsStr;
}

function calcEquipmentAndClassStr(equipment) {
  var equipmentAndClassStr = 0;

  if (equipment != undefined) {  
    equipmentAndClassStr += equipment.str;
    if (equipment.klass == user.stats.class) {
      equipmentAndClassStr += equipment.str / 2;
    }
  }
  
  return equipmentAndClassStr;
}

function calculateIntelligence() {
  const levelInt = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassInt = 0;
  const allocatedInt = user.stats.int;
  const buffsInt = user.stats.buffs.int;

  // Get INT from equipped gear
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.back]);

  return levelInt + totalEquipmentAndClassInt + allocatedInt + buffsInt;
}

function calcEquipmentAndClassInt(equipment) {
  var equipmentAndClassInt = 0;

  if (equipment != undefined) {  
    equipmentAndClassInt += equipment.int;
    if (equipment.klass == user.stats.class) {
      equipmentAndClassInt += equipment.int / 2;
    }
  }
  
  return equipmentAndClassInt;
}

function calculateConstitution() {
  const levelCon = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassCon = 0;
  const allocatedCon = user.stats.con;
  const buffsCon = user.stats.buffs.con;
  
  // Get CON from equipped gear
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.back]);

  return levelCon + totalEquipmentAndClassCon + allocatedCon + buffsCon;
}

function calcEquipmentAndClassCon(equipment) {
  var equipmentAndClassCon = 0;

  if (equipment != undefined) {  
    equipmentAndClassCon += equipment.con;
    if (equipment.klass == user.stats.class) {
      equipmentAndClassCon += equipment.con / 2;
    }
  }
  
  return equipmentAndClassCon;
}

function calculatePerception() {
  const levelPer = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassPer = 0;
  const allocatedPer = user.stats.per;
  const buffsPer = user.stats.buffs.per;
  
  // Get PER from equipped gear
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.back]);

  return levelPer + totalEquipmentAndClassPer + allocatedPer + buffsPer;
}

function calcEquipmentAndClassPer(equipment) {
  var equipmentAndClassPer = 0;

  if (equipment != undefined) {  
    equipmentAndClassPer += equipment.per;
    if (equipment.klass == user.stats.class) {
      equipmentAndClassPer += equipment.per / 2;
    }
  }
  
  return equipmentAndClassPer;
}

// Send a notification as a private message, only if they're enabled
function api_sendPrivateMessage(payload) {
  switch (NOTIFICATIONS_ON){ // Check if notifications are on, send message if yes
        case 0:
          break;        
        case 1:
            const params = {
              "method" : "post",
              "headers" : HEADERS,
              "contentType" : "application/json",
              "payload" : JSON.stringify(payload),
              "muteHttpExceptions" : true,
            }
            const url = "https://habitica.com/api/v3/members/send-private-message";
            return UrlFetchApp.fetch(url, params);
          break;
  }
}
